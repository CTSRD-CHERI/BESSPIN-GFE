//
// Generated by Bluespec Compiler, version 2017.07.A (build e1df8052c, 2017-07-21)
//
//
//
//
// Ports:
// Name                         I/O  size props
// RDY_set_addr_map               O     1 const
// slave_awready                  O     1 reg
// slave_wready                   O     1 reg
// slave_bvalid                   O     1 reg
// slave_bid                      O     4 reg
// slave_bresp                    O     2 reg
// slave_arready                  O     1 reg
// slave_rvalid                   O     1 reg
// slave_rid                      O     4 reg
// slave_rdata                    O    64 reg
// slave_rresp                    O     2 reg
// slave_rlast                    O     1 reg
// assert_soft_reset              O     1 reg
// RDY_assert_soft_reset          O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// set_addr_map_addr_base         I    64 reg
// set_addr_map_addr_lim          I    64 reg
// slave_awvalid                  I     1
// slave_awid                     I     4 reg
// slave_awaddr                   I    64 reg
// slave_awlen                    I     8 reg
// slave_awsize                   I     3 reg
// slave_awburst                  I     2 reg
// slave_awlock                   I     1 reg
// slave_awcache                  I     4 reg
// slave_awprot                   I     3 reg
// slave_awqos                    I     4 reg
// slave_awregion                 I     4 reg
// slave_wvalid                   I     1
// slave_wdata                    I    64 reg
// slave_wstrb                    I     8 reg
// slave_wlast                    I     1 reg
// slave_bready                   I     1
// slave_arvalid                  I     1
// slave_arid                     I     4 reg
// slave_araddr                   I    64 reg
// slave_arlen                    I     8 reg
// slave_arsize                   I     3 reg
// slave_arburst                  I     2 reg
// slave_arlock                   I     1 reg
// slave_arcache                  I     4 reg
// slave_arprot                   I     3 reg
// slave_arqos                    I     4 reg
// slave_arregion                 I     4 reg
// slave_rready                   I     1
// EN_set_addr_map                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAES(CLK,
	      RST_N,

	      set_addr_map_addr_base,
	      set_addr_map_addr_lim,
	      EN_set_addr_map,
	      RDY_set_addr_map,

	      slave_awvalid,
	      slave_awid,
	      slave_awaddr,
	      slave_awlen,
	      slave_awsize,
	      slave_awburst,
	      slave_awlock,
	      slave_awcache,
	      slave_awprot,
	      slave_awqos,
	      slave_awregion,

	      slave_awready,

	      slave_wvalid,
	      slave_wdata,
	      slave_wstrb,
	      slave_wlast,

	      slave_wready,

	      slave_bvalid,

	      slave_bid,

	      slave_bresp,

	      slave_bready,

	      slave_arvalid,
	      slave_arid,
	      slave_araddr,
	      slave_arlen,
	      slave_arsize,
	      slave_arburst,
	      slave_arlock,
	      slave_arcache,
	      slave_arprot,
	      slave_arqos,
	      slave_arregion,

	      slave_arready,

	      slave_rvalid,

	      slave_rid,

	      slave_rdata,

	      slave_rresp,

	      slave_rlast,

	      slave_rready,

	      assert_soft_reset,
	      RDY_assert_soft_reset);
  input  CLK;
  input  RST_N;

  // action method set_addr_map
  input  [63 : 0] set_addr_map_addr_base;
  input  [63 : 0] set_addr_map_addr_lim;
  input  EN_set_addr_map;
  output RDY_set_addr_map;

  // action method slave_m_awvalid
  input  slave_awvalid;
  input  [3 : 0] slave_awid;
  input  [63 : 0] slave_awaddr;
  input  [7 : 0] slave_awlen;
  input  [2 : 0] slave_awsize;
  input  [1 : 0] slave_awburst;
  input  slave_awlock;
  input  [3 : 0] slave_awcache;
  input  [2 : 0] slave_awprot;
  input  [3 : 0] slave_awqos;
  input  [3 : 0] slave_awregion;

  // value method slave_m_awready
  output slave_awready;

  // action method slave_m_wvalid
  input  slave_wvalid;
  input  [63 : 0] slave_wdata;
  input  [7 : 0] slave_wstrb;
  input  slave_wlast;

  // value method slave_m_wready
  output slave_wready;

  // value method slave_m_bvalid
  output slave_bvalid;

  // value method slave_m_bid
  output [3 : 0] slave_bid;

  // value method slave_m_bresp
  output [1 : 0] slave_bresp;

  // value method slave_m_buser

  // action method slave_m_bready
  input  slave_bready;

  // action method slave_m_arvalid
  input  slave_arvalid;
  input  [3 : 0] slave_arid;
  input  [63 : 0] slave_araddr;
  input  [7 : 0] slave_arlen;
  input  [2 : 0] slave_arsize;
  input  [1 : 0] slave_arburst;
  input  slave_arlock;
  input  [3 : 0] slave_arcache;
  input  [2 : 0] slave_arprot;
  input  [3 : 0] slave_arqos;
  input  [3 : 0] slave_arregion;

  // value method slave_m_arready
  output slave_arready;

  // value method slave_m_rvalid
  output slave_rvalid;

  // value method slave_m_rid
  output [3 : 0] slave_rid;

  // value method slave_m_rdata
  output [63 : 0] slave_rdata;

  // value method slave_m_rresp
  output [1 : 0] slave_rresp;

  // value method slave_m_rlast
  output slave_rlast;

  // value method slave_m_ruser

  // action method slave_m_rready
  input  slave_rready;

  // value method assert_soft_reset
  output assert_soft_reset;
  output RDY_assert_soft_reset;

  // Limited capability AXI data width converter
  // Assumptions: Only 32 bit, incrementing burst transactions are used
  wire [31:0] slave_wdata_small;
  wire [31:0] slave_rdata_small;
  wire [3:0] slave_wstrb_small;

  always_comb begin
    // Write channel conversion
    if(slave_awaddr[2] == 0) begin
      slave_wdata_small = slave_wdata[31:0];
      slave_wstrb_small = slave_wstrb[3:0];
    end else begin
      slave_wdata_small = slave_wdata[63:32];
      slave_wstrb_small = slave_wstrb[7:4];
    end

    // Read channel conversion
    assign slave_rdata = {slave_rdata_small, slave_rdata_small};
  end

  // end data width converter

  // Insert AES AXI component where the GPIO should be
  // TODO: Create a separate AXI port for the AES accelerator
  AES_AXI_wrapper_v1_0 #(
    .C_S00_AXI_DATA_WIDTH  (32)
    ) i_aex_axi (
    // Users to add ports here
    .done_irq(),
    // User ports ends
    // Do not modify the ports beyond this line

    // Ports of Axi Slave Bus Interface S00_AXI
    .s00_axi_aclk(CLK), // input wire
    .s00_axi_aresetn(RST_N), // input wire
    .s00_axi_awid(slave_awid), // input wire
    .s00_axi_awaddr(slave_awaddr), // input wire
    .s00_axi_awlen(slave_awlen), // input wire
    .s00_axi_awsize(slave_awsize), // input wire
    .s00_axi_awburst(slave_awburst), // input wire
    .s00_axi_awlock(slave_awlock), // input wire
    .s00_axi_awcache(slave_awcache), // input wire
    .s00_axi_awprot(slave_awprot), // input wire
    .s00_axi_awqos(slave_awqos), // input wire
    .s00_axi_awregion(slave_awregion), // input wire
    .s00_axi_awuser(), // input wire
    .s00_axi_awvalid(slave_awvalid), // input wire
    .s00_axi_awready(slave_awready), // output wire
    .s00_axi_wdata(slave_wdata_small), // input wire
    .s00_axi_wstrb(slave_wstrb_small), // input wire
    .s00_axi_wlast(slave_wlast), // input wire
    .s00_axi_wuser(), // input wire
    .s00_axi_wvalid(slave_wvalid), // input wire
    .s00_axi_wready(slave_wready), // output wire
    .s00_axi_bid(slave_bid), // output wire
    .s00_axi_bresp(slave_bresp), // output wire
    .s00_axi_buser(), // output wire
    .s00_axi_bvalid(slave_bvalid), // output wire
    .s00_axi_bready(slave_bready), // input wire
    .s00_axi_arid(slave_arid), // input wire
    .s00_axi_araddr(slave_araddr), // input wire
    .s00_axi_arlen(slave_arlen), // input wire
    .s00_axi_arsize(slave_arsize), // input wire
    .s00_axi_arburst(slave_arburst), // input wire
    .s00_axi_arlock(slave_arlock), // input wire
    .s00_axi_arcache(slave_arcache), // input wire
    .s00_axi_arprot(slave_arprot), // input wire
    .s00_axi_arqos(slave_arqos), // input wire
    .s00_axi_arregion(slave_arregion), // input wire
    .s00_axi_aruser(), // input wire
    .s00_axi_arvalid(slave_arvalid), // input wire
    .s00_axi_arready(slave_arready), // output wire
    .s00_axi_rid(slave_rid), // output wire
    .s00_axi_rdata(slave_rdata_small), // output wire
    .s00_axi_rresp(slave_rresp), // output wire
    .s00_axi_rlast(slave_rlast), // output wire
    .s00_axi_ruser(), // output wire
    .s00_axi_rvalid(slave_rvalid), // output wire
    .s00_axi_rready(slave_rready) // input wire
  );

  // Fix the extra GPIO values
  assign assert_soft_reset = 1'b0;
  assign RDY_assert_soft_reset = 1'b1;
  assign RDY_set_addr_map = 1'b1;

  // synopsys translate_on
endmodule  // mkGpio

